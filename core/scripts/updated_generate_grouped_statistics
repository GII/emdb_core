import pandas as pd
import ast
import matplotlib.pyplot as plt
import magic
import sys
import bz2
import argparse
import os

def open_file(name):
    """Open a file using its magic number to identify its contents."""
    file_type = magic.from_file(name)
    if "text" in file_type:
        return open(name, encoding="utf-8")
    if "bzip2" in file_type:
        return bz2.open(name)
    print("Unsupported file!!!")
    sys.exit(1)

def file_number(file):
    i = 0
    name, extension = os.path.splitext(file)
    while os.path.exists(name + "_" + str(i) + extension):
        i = i + 1

    def_file_name = name + "_" + str(i) + extension
    return def_file_name

def strtobool(val):
    """Convert a string representation of truth to true (1) or false (0)."""
    val = val.lower()
    if val in ("y", "yes", "t", "true", "on", "1"):
        return True
    if val in ("n", "no", "f", "false", "off", "0"):
        return False
    raise ValueError(f"invalid truth value {val}")

def obtain_rewards_dict(file):
    """Read the goal rewards from goodness files"""
    f = open_file(file)

    dataset = pd.read_csv(f, delimiter='\t', header=0)

    rewards_str = dataset["Goal reward list"].to_list()
    rewards = [ast.literal_eval(goal) for goal in rewards_str]


    rewards_dataset = pd.DataFrame(rewards)

    iterations = dataset["Iteration"].to_list()
    changes = dataset["Sensorial changes"].to_list()
    rewards_per_goal = rewards_dataset.to_dict(orient = 'list')
    
    return iterations, rewards_per_goal, changes


def generate_grouped_statistics(goal_name, iterations, rewards, changes, max_ite):
    """Calculate goals statistics using bunchs of iterations."""
    data = []
    accumulated_reward = 0.0
    no_change_iterations = 0
    rewarded_iterations = 0
    
    if len(iterations) != len(rewards) or len(rewards) != len(changes):
        raise ValueError("Error. Dimensions do not match")

    for i in range(len(iterations)):
        iteration = int(iterations[i])
        reward = float(rewards[i])
        change = int(changes[i])
        accumulated_reward += reward
        if not change:
            no_change_iterations+=1
        if reward > 0.01:
            rewarded_iterations+=1

        if iteration % max_ite == 0 and iteration > 0:
            data.append({
                "Iteration":iteration,
                "Avg_reward":accumulated_reward/max_ite*100,
                "NoChange_Iterations":no_change_iterations,
                "Rewarded_Iterations":rewarded_iterations
            })

            accumulated_reward = 0.0
            no_change_iterations = 0
            rewarded_iterations = 0

    df = pd.DataFrame(data)
    file_name = f"{goal_name}_goodness.csv"
    def_file_name = file_number(file_name)
    df.to_csv(def_file_name, sep = "\t", index=False)

    data_to_plot = df.to_dict(orient="list")
    return data_to_plot

def plot_data(all_data, max_ite, show_figures):
    """Plot the generated statistics."""
    for data_dict in all_data:
        for data in data_dict.values():
            goal_name = list(data_dict.keys())[0]
            plt.figure(figsize=(16,10))
            plt.title(goal_name, fontsize = 18)
            plt.xlabel("Iterations", fontsize = 15)
            plt.ylabel("% Success", fontsize = 15)
            plt.xlim(0,data["Iteration"][-1])
            plt.xticks(range(0, data["Iteration"][-1]+1, 1000))
            plt.ylim(-2,100)
            plt.yticks(range(0, 101, 10))
            plt.tick_params(labelsize = 12)
            plt.plot(data["Iteration"], data["Avg_reward"], label = goal_name)
            plt.legend(loc="center right", fontsize = 15)
            plt.grid(linewidth = 0.3)
            img_name = f"{goal_name}_n{max_ite}.svg"
            def_img_name = file_number(img_name)
            plt.savefig(def_img_name)
            if show_figures:
                plt.show()

    plt.figure(figsize=(16,10))
    plt.title("All goals", fontsize = 18)
    plt.xlabel("Iterations", fontsize = 15)
    plt.ylabel("% Success", fontsize = 15)
    plt.xlim(0,data["Iteration"][-1])
    plt.xticks(range(0, data["Iteration"][-1]+1, 1000))
    plt.ylim(-2,100)
    plt.yticks(range(0, 101, 10))
    plt.tick_params(labelsize = 12)
    for data_dict in all_data:
        for data in data_dict.values():
            goal_name = list(data_dict.keys())[0]
            plt.plot(data["Iteration"], data["Avg_reward"], label = goal_name)
    plt.legend(loc="center right", fontsize = 15)
    plt.grid(linewidth = 0.3)
    img_name = f"all_goals_n{max_ite}.svg"
    def_img_name = file_number(img_name)
    plt.savefig(def_img_name)
    if show_figures:
        plt.show()

def main():
    parser = argparse.ArgumentParser(
        description="Calculate several statistics for LTM experiments using bunchs of iterations"
    )
    parser.add_argument(
        "-f", "--file", help="File with statistics for every iteration of an experiment"
    )
    parser.add_argument(
        "-n",
        "--iterations",
        type=int,
        help="Number of consecutive iterations used to calculate the statistics",
    )

    parser.add_argument(
        "-fg",
        "--figures",
        default = "true",
        help="Select if the user wants to generate figures or only the output files"
    )

    parser.add_argument(
        "-s",
        "--show_figures",
        default = "true",
        help="Select if the user wants to show the figures after execution"
    )


    args = parser.parse_args()
    kwargs = vars(args)
    file_name = kwargs["file"]
    max_ite = kwargs["iterations"]
    figures = strtobool(kwargs["figures"])
    show_figures = strtobool(kwargs["show_figures"])
    
    all_data_to_plot = []
    iterations, rewards_per_goal, changes = obtain_rewards_dict(file_name)
    for goal in rewards_per_goal:
        data_to_plot = generate_grouped_statistics(goal, iterations, rewards_per_goal[goal], changes, max_ite)
        data_to_plot_dict = {goal:data_to_plot}
        all_data_to_plot.append(data_to_plot_dict)

    if figures: 
        plot_data(all_data_to_plot, max_ite, show_figures)
        
        
if __name__ == "__main__":
    main()
